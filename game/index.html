<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <title>Advanced 3D Open World GTA - Mobile Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
            position: fixed;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #000428, #004e92);
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        /* Mobile Controls */
        .mobile-controls {
            position: absolute;
            pointer-events: all;
            user-select: none;
            z-index: 200;
        }
        
        #joystick {
            bottom: 50px;
            left: 50px;
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 30px rgba(0,150,255,0.3);
        }
        
        #joystick-knob {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #00aaff, #0066cc);
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 20px rgba(0,170,255,0.8);
            border: 2px solid rgba(255,255,255,0.4);
        }
        
        #actionButtons {
            bottom: 50px;
            right: 50px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .action-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.4);
            background: radial-gradient(circle, rgba(255,100,100,0.8), rgba(200,50,50,0.6));
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            box-shadow: 0 0 25px rgba(255,100,100,0.5);
            transition: all 0.1s;
        }
        
        .action-btn:active {
            transform: scale(0.95);
            box-shadow: 0 0 35px rgba(255,100,100,0.8);
        }
        
        .action-btn.shoot {
            background: radial-gradient(circle, rgba(255,50,50,0.9), rgba(150,0,0,0.7));
        }
        
        .action-btn.interact {
            background: radial-gradient(circle, rgba(50,255,50,0.9), rgba(0,150,0,0.7));
        }
        
        .action-btn.phone {
            background: radial-gradient(circle, rgba(255,255,50,0.9), rgba(200,200,0,0.7));
        }
        
        /* HUD Elements */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid rgba(0,150,255,0.5);
            box-shadow: 0 0 30px rgba(0,150,255,0.3);
            backdrop-filter: blur(10px);
            max-width: 250px;
        }
        
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid rgba(0,150,255,0.5);
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0,150,255,0.3);
            backdrop-filter: blur(10px);
        }
        
        #weaponHUD {
            position: absolute;
            bottom: 200px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px;
            border-radius: 10px;
            border: 2px solid rgba(255,100,100,0.5);
            box-shadow: 0 0 20px rgba(255,100,100,0.3);
        }
        
        #phoneModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 400px;
            background: linear-gradient(145deg, #1a1a1a, #2a2a2a);
            border-radius: 25px;
            border: 3px solid rgba(255,255,255,0.3);
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            padding: 20px;
            backdrop-filter: blur(20px);
        }
        
        .phone-button {
            padding: 15px;
            margin: 10px 0;
            background: linear-gradient(145deg, #333, #555);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            color: white;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .phone-button:active {
            transform: scale(0.98);
            background: linear-gradient(145deg, #555, #777);
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            pointer-events: none;
            z-index: 1000;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 50, 50, 0.9);
            box-shadow: 0 0 10px rgba(255,50,50,0.8);
        }
        
        #crosshair::before {
            width: 3px;
            height: 30px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        #crosshair::after {
            width: 30px;
            height: 3px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .notification {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.95);
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid rgba(255,255,255,0.3);
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            opacity: 0;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }
        
        .notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(20px);
        }
        
        .health-bar {
            width: 100%;
            height: 12px;
            background: rgba(255,0,0,0.3);
            border-radius: 6px;
            margin: 8px 0;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6666, #ffaaaa);
            width: 100%;
            transition: width 0.3s ease;
            box-shadow: inset 0 0 10px rgba(255,255,255,0.3);
        }
        
        .wanted-level {
            display: flex;
            gap: 5px;
            margin: 5px 0;
        }
        
        .star {
            width: 20px;
            height: 20px;
            background: linear-gradient(45deg, #ffaa00, #ff6600);
            clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
            opacity: 0.3;
            transition: opacity 0.3s;
        }
        
        .star.active {
            opacity: 1;
            box-shadow: 0 0 15px rgba(255,170,0,0.8);
        }
        
        h3, h4 {
            margin: 0 0 8px 0;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        
        @media (orientation: landscape) {
            #joystick {
                bottom: 30px;
                left: 30px;
                width: 100px;
                height: 100px;
            }
            
            #joystick-knob {
                width: 40px;
                height: 40px;
            }
            
            #actionButtons {
                bottom: 30px;
                right: 30px;
                flex-direction: row;
            }
            
            .action-btn {
                width: 60px;
                height: 60px;
                font-size: 14px;
            }
            
            #hud {
                max-width: 200px;
                font-size: 12px;
            }
            
            #minimap {
                width: 120px;
                height: 120px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <!-- Mobile Controls -->
            <div id="joystick" class="mobile-controls">
                <div id="joystick-knob"></div>
            </div>
            
            <div id="actionButtons" class="mobile-controls">
                <div class="action-btn shoot" id="shootBtn">üî´</div>
                <div class="action-btn interact" id="interactBtn">üí¨</div>
                <div class="action-btn phone" id="phoneBtn">üì±</div>
                <div class="action-btn" id="jumpBtn">‚¨ÜÔ∏è</div>
            </div>
            
            <!-- HUD -->
            <div id="hud">
                <h4>Player Status</h4>
                <div>Health: <div class="health-bar"><div class="health-fill" id="healthBar"></div></div></div>
                <div>Speed: <span id="speed">0</span> km/h</div>
                <div>Ammo: <span id="ammo">30/120</span></div>
                <div>Money: $<span id="money">1000</span></div>
                <div>Wanted Level:</div>
                <div class="wanted-level" id="wantedLevel">
                    <div class="star"></div>
                    <div class="star"></div>
                    <div class="star"></div>
                    <div class="star"></div>
                    <div class="star"></div>
                </div>
            </div>
            
            <div id="minimap">
                <canvas id="minimapCanvas" width="150" height="150"></canvas>
            </div>
            
            <div id="weaponHUD">
                <h4>Weapon</h4>
                <div id="currentWeapon">Pistol</div>
                <div id="weaponAmmo">30/120</div>
            </div>
            
            <!-- Phone Modal -->
            <div id="phoneModal" class="mobile-controls">
                <h3>üì± Phone</h3>
                <div class="phone-button" onclick="callPolice()">üöî Call Police</div>
                <div class="phone-button" onclick="callAmbulance()">üöë Call Ambulance</div>
                <div class="phone-button" onclick="callTaxi()">üöï Call Taxi</div>
                <div class="phone-button" onclick="closePhone()">‚ùå Close</div>
            </div>
            
            <div id="crosshair"></div>
            
            <div id="notification" class="notification"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
        // Advanced Game State
        let scene, camera, renderer, player, vehicles = [], npcs = [], buildings = [], bullets = [];
        let loader = new THREE.GLTFLoader();
        let clock = new THREE.Clock();
        let minimapCtx;
        
        // Mobile controls
        let joystick = { active: false, center: { x: 0, y: 0 }, current: { x: 0, y: 0 } };
        let touchControls = { moveX: 0, moveY: 0, shooting: false };
        
        let gameState = {
            health: 100,
            money: 1000,
            ammo: 30,
            maxAmmo: 120,
            wantedLevel: 0,
            isRunning: false,
            isShooting: false,
            inVehicle: false,
            currentVehicle: null,
            currentWeapon: 'pistol',
            phoneOpen: false,
            nearNPC: null,
            playerModel: null,
            animations: {},
            mixer: null
        };
        
        // Game constants
        const WALK_SPEED = 0.2;
        const RUN_SPEED = 0.4;
        const VEHICLE_SPEED = 1.0;
        const BULLET_SPEED = 2.0;
        const WORLD_SIZE = 150;
        
        function init() {
            console.log("Initializing Advanced Mobile 3D Open World Game...");
            
            // Create scene with enhanced atmosphere
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 100, 400);
            
            // Enhanced skybox with gradient
            const skyGeometry = new THREE.SphereGeometry(800, 32, 32);
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: new THREE.Color(0x0077ff) },
                    bottomColor: { value: new THREE.Color(0xffffff) },
                    offset: { value: 33 },
                    exponent: { value: 0.6 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
            
            // Mobile-optimized camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 8, 15);
            
            // High-performance renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance",
                stencil: false,
                depth: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x87CEEB);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Setup all game systems
            setupAdvancedLighting();
            createRealisticEnvironment();
            loadPlayerModel();
            createAdvancedVehicles();
            createIntelligentNPCs();
            setupMobileControls();
            setupMinimap();
            
            // Start enhanced game loop
            animate();
            updateUI();
            
            console.log("Advanced Mobile 3D Game initialized!");
        }
        
        function setupAdvancedLighting() {
            // Enhanced ambient lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            // Dynamic sun with realistic shadows
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(200, 300, 100);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 1000;
            directionalLight.shadow.camera.left = -200;
            directionalLight.shadow.camera.right = 200;
            directionalLight.shadow.camera.top = 200;
            directionalLight.shadow.camera.bottom = -200;
            directionalLight.shadow.bias = -0.0001;
            scene.add(directionalLight);
            
            // Atmospheric lighting
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x2d5a27, 0.4);
            scene.add(hemisphereLight);
            
            // Dynamic street lighting
            createDynamicStreetLights();
        }
        
        function createDynamicStreetLights() {
            for (let x = -4; x <= 4; x++) {
                for (let z = -4; z <= 4; z++) {
                    if (x !== 0 || z !== 0) {
                        const light = new THREE.PointLight(0xffaa44, 0.8, 40);
                        light.position.set(x * 40, 8, z * 40);
                        light.castShadow = true;
                        light.shadow.mapSize.width = 512;
                        light.shadow.mapSize.height = 512;
                        scene.add(light);
                        
                        // Light pole
                        const poleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 12);
                        const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
                        const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                        pole.position.set(x * 40, 6, z * 40);
                        pole.castShadow = true;
                        scene.add(pole);
                    }
                }
            }
        }
        
        function createRealisticEnvironment() {
            // Enhanced ground with realistic textures
            const groundGeometry = new THREE.PlaneGeometry(WORLD_SIZE * 2, WORLD_SIZE * 2, 100, 100);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2d5a27,
                transparent: true,
                opacity: 0.9
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Create detailed urban environment
            createAdvancedCityscape();
            createRealisticStreets();
            createUrbanProps();
            createNaturalElements();
        }
        
        function createAdvancedCityscape() {
            const buildingConfigs = [
                // Skyscrapers with realistic proportions
                { x: 0, z: 0, w: 20, h: 60, d: 20, color: 0x4682b4, type: 'skyscraper', windows: true },
                { x: 50, z: 50, w: 18, h: 55, d: 18, color: 0x696969, type: 'skyscraper', windows: true },
                { x: -50, z: 50, w: 16, h: 45, d: 16, color: 0x8b4513, type: 'skyscraper', windows: true },
                { x: 50, z: -50, w: 22, h: 65, d: 22, color: 0x2f4f4f, type: 'skyscraper', windows: true },
                { x: -50, z: -50, w: 19, h: 50, d: 19, color: 0x8b0000, type: 'skyscraper', windows: true },
                
                // Mid-rise buildings
                { x: 80, z: 0, w: 12, h: 25, d: 12, color: 0x9acd32, type: 'midrise', windows: true },
                { x: -80, z: 0, w: 14, h: 30, d: 14, color: 0xd2691e, type: 'midrise', windows: true },
                { x: 0, z: 80, w: 10, h: 20, d: 10, color: 0x708090, type: 'midrise', windows: true },
                { x: 0, z: -80, w: 13, h: 28, d: 13, color: 0x4169e1, type: 'midrise', windows: true },
                
                // Residential complexes
                { x: 70, z: 70, w: 8, h: 15, d: 8, color: 0xffa500, type: 'residential', windows: true },
                { x: -70, z: 70, w: 7, h: 12, d: 7, color: 0x32cd32, type: 'residential', windows: true },
                { x: 70, z: -70, w: 9, h: 18, d: 9, color: 0xff69b4, type: 'residential', windows: true },
                { x: -70, z: -70, w: 8, h: 14, d: 8, color: 0x1e90ff, type: 'residential', windows: true },
                
                // Commercial buildings
                { x: 100, z: 30, w: 15, h: 10, d: 25, color: 0xffd700, type: 'commercial', windows: true },
                { x: -100, z: 30, w: 12, h: 8, d: 22, color: 0xdc143c, type: 'commercial', windows: true },
                { x: 100, z: -30, w: 18, h: 12, d: 28, color: 0x00ced1, type: 'commercial', windows: true },
                { x: -100, z: -30, w: 14, h: 10, d: 24, color: 0x9370db, type: 'commercial', windows: true }
            ];
            
            buildingConfigs.forEach((config, index) => {
                const building = createRealisticBuilding(config);
                building.userData.id = index;
                buildings.push(building);
                scene.add(building);
            });
        }
        
        function createRealisticBuilding(config) {
            const group = new THREE.Group();
            
            // Main building structure with improved materials
            const geometry = new THREE.BoxGeometry(config.w, config.h, config.d);
            const material = new THREE.MeshLambertMaterial({ 
                color: config.color,
                transparent: true,
                opacity: 0.9
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = config.h / 2;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            group.add(mesh);
            
            // Enhanced windows system
            if (config.windows && config.h > 10) {
                for (let floor = 3; floor < config.h - 2; floor += 4) {
                    // Front and back windows
                    for (let side = 0; side < 4; side++) {
                        const windowCount = Math.floor(Math.max(config.w, config.d) / 4);
                        for (let w = 0; w < windowCount; w++) {
                            const window = createAdvancedWindow();
                            const angle = (side * Math.PI) / 2;
                            const distance = side % 2 === 0 ? config.w / 2 + 0.1 : config.d / 2 + 0.1;
                            
                            window.position.x = Math.sin(angle) * distance;
                            window.position.z = Math.cos(angle) * distance;
                            window.position.y = floor;
                            window.rotation.y = angle;
                            
                            const offset = side % 2 === 0 ? config.d : config.w;
                            const spacing = offset / (windowCount + 1);
                            window.position.x += Math.cos(angle) * (w - windowCount/2 + 0.5) * spacing;
                            window.position.z += -Math.sin(angle) * (w - windowCount/2 + 0.5) * spacing;
                            
                            group.add(window);
                        }
                    }
                }
            }
            
            // Rooftop details for skyscrapers
            if (config.type === 'skyscraper') {
                const rooftop = createRooftopDetails(config);
                rooftop.position.y = config.h;
                group.add(rooftop);
            }
            
            group.position.set(config.x, 0, config.z);
            return group;
        }
        
        function createAdvancedWindow() {
            const group = new THREE.Group();
            
            // Window frame
            const frameGeometry = new THREE.PlaneGeometry(2, 2);
            const frameMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            group.add(frame);
            
            // Glass with reflection
            const glassGeometry = new THREE.PlaneGeometry(1.6, 1.6);
            const glassMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            const glass = new THREE.Mesh(glassGeometry, glassMaterial);
            glass.position.z = 0.01;
            group.add(glass);
            
            // Random light in some windows (nighttime effect)
            if (Math.random() > 0.7) {
                const light = new THREE.Mesh(
                    new THREE.PlaneGeometry(1.4, 1.4),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xffffaa,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                light.position.z = 0.02;
                group.add(light);
            }
            
            return group;
        }
        
        function createRooftopDetails(config) {
            const group = new THREE.Group();
            
            // Antenna
            const antenna = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.1, 8),
                new THREE.MeshLambertMaterial({ color: 0x666666 })
            );
            antenna.position.y = 4;
            antenna.castShadow = true;
            group.add(antenna);
            
            // Rooftop structures
            for (let i = 0; i < 3; i++) {
                const structure = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 1, 2),
                    new THREE.MeshLambertMaterial({ color: 0x555555 })
                );
                structure.position.set(
                    (Math.random() - 0.5) * config.w * 0.6,
                    0.5,
                    (Math.random() - 0.5) * config.d * 0.6
                );
                structure.castShadow = true;
                group.add(structure);
            }
            
            return group;
        }
        
        function createRealisticStreets() {
            const streetMaterial = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
            const sidewalkMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            
            // Main road network
            for (let i = -5; i <= 5; i++) {
                // Horizontal streets
                const street = new THREE.Mesh(
                    new THREE.PlaneGeometry(WORLD_SIZE * 2, 12),
                    streetMaterial
                );
                street.rotation.x = -Math.PI / 2;
                street.position.set(0, 0.02, i * 40);
                street.receiveShadow = true;
                scene.add(street);
                
                // Street markings
                const centerLine = new THREE.Mesh(
                    new THREE.PlaneGeometry(WORLD_SIZE * 2, 0.2),
                    lineMaterial
                );
                centerLine.rotation.x = -Math.PI / 2;
                centerLine.position.set(0, 0.03, i * 40);
                scene.add(centerLine);
                
                // Vertical streets
                const street2 = new THREE.Mesh(
                    new THREE.PlaneGeometry(12, WORLD_SIZE * 2),
                    streetMaterial
                );
                street2.rotation.x = -Math.PI / 2;
                street2.position.set(i * 40, 0.02, 0);
                street2.receiveShadow = true;
                scene.add(street2);
                
                const centerLine2 = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.2, WORLD_SIZE * 2),
                    lineMaterial
                );
                centerLine2.rotation.x = -Math.PI / 2;
                centerLine2.position.set(i * 40, 0.03, 0);
                scene.add(centerLine2);
                
                // Enhanced sidewalks
                for (let side = -1; side <= 1; side += 2) {
                    const sidewalk = new THREE.Mesh(
                        new THREE.PlaneGeometry(WORLD_SIZE * 2, 3),
                        sidewalkMaterial
                    );
                    sidewalk.rotation.x = -Math.PI / 2;
                    sidewalk.position.set(0, 0.04, i * 40 + side * 7.5);
                    sidewalk.receiveShadow = true;
                    scene.add(sidewalk);
                    
                    const sidewalk2 = new THREE.Mesh(
                        new THREE.PlaneGeometry(3, WORLD_SIZE * 2),
                        sidewalkMaterial
                    );
                    sidewalk2.rotation.x = -Math.PI / 2;
                    sidewalk2.position.set(i * 40 + side * 7.5, 0.04, 0);
                    sidewalk2.receiveShadow = true;
                    scene.add(sidewalk2);
                }
            }
        }
        
        function createUrbanProps() {
            // Traffic lights at intersections
            createTrafficSystem();
            
            // Street furniture
            createStreetFurniture();
            
            // Vehicle spawns
            createParkingAreas();
        }
        
        function createTrafficSystem() {
            const intersections = [];
            for (let x = -4; x <= 4; x++) {
                for (let z = -4; z <= 4; z++) {
                    if (x !== 0 || z !== 0) {
                        intersections.push({ x: x * 40, z: z * 40 });
                    }
                }
            }
            
            intersections.forEach(pos => {
                const trafficLight = createAdvancedTrafficLight();
                trafficLight.position.set(pos.x + 10, 0, pos.z + 10);
                scene.add(trafficLight);
            });
        }
        
        function createAdvancedTrafficLight() {
            const group = new THREE.Group();
            
            // Enhanced pole
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 8),
                new THREE.MeshLambertMaterial({ color: 0x444444 })
            );
            pole.position.y = 4;
            pole.castShadow = true;
            group.add(pole);
            
            // Traffic light box
            const box = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 3, 0.8),
                new THREE.MeshLambertMaterial({ color: 0x222222 })
            );
            box.position.y = 7;
            box.castShadow = true;
            group.add(box);
            
            // Animated lights
            const colors = [0xff0000, 0xffff00, 0x00ff00];
            colors.forEach((color, i) => {
                const lightBulb = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2),
                    new THREE.MeshBasicMaterial({ 
                        color: color,
                        emissive: color,
                        emissiveIntensity: 0.3
                    })
                );
                lightBulb.position.set(0, 7.5 - (i * 0.8), 0.5);
                group.add(lightBulb);
                
                // Add point light for glow effect
                const pointLight = new THREE.PointLight(color, 0.3, 10);
                pointLight.position.copy(lightBulb.position);
                group.add(pointLight);
            });
            
            return group;
        }
        
        function createStreetFurniture() {
            const furnitureItems = [
                // Bus stops
                { pos: { x: 60, z: 12 }, type: 'busStop' },
                { pos: { x: -60, z: 12 }, type: 'busStop' },
                { pos: { x: 12, z: 60 }, type: 'busStop' },
                { pos: { x: 12, z: -60 }, type: 'busStop' },
                
                // ATMs
                { pos: { x: 45, z: 8 }, type: 'atm' },
                { pos: { x: -45, z: 8 }, type: 'atm' },
                
                // Phone booths
                { pos: { x: 35, z: 15 }, type: 'phone' },
                { pos: { x: -35, z: 15 }, type: 'phone' }
            ];
            
            furnitureItems.forEach(item => {
                let furniture;
                switch(item.type) {
                    case 'busStop':
                        furniture = createBusStop();
                        break;
                    case 'atm':
                        furniture = createATM();
                        break;
                    case 'phone':
                        furniture = createPhoneBooth();
                        break;
                }
                if (furniture) {
                    furniture.position.set(item.pos.x, 0, item.pos.z);
                    scene.add(furniture);
                }
            });
        }
        
        function createBusStop() {
            const group = new THREE.Group();
            
            // Shelter
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(6, 0.3, 3),
                new THREE.MeshLambertMaterial({ color: 0x666666 })
            );
            roof.position.y = 3;
            roof.castShadow = true;
            group.add(roof);
            
            // Support columns
            for (let i = 0; i < 3; i++) {
                const column = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 3),
                    new THREE.MeshLambertMaterial({ color: 0x444444 })
                );
                column.position.set(i * 2.5 - 2.5, 1.5, -1.2);
                column.castShadow = true;
                group.add(column);
            }
            
            // Bench
            const bench = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.4, 1),
                new THREE.MeshLambertMaterial({ color: 0x8b4513 })
            );
            bench.position.set(0, 1.2, -0.5);
            bench.castShadow = true;
            group.add(bench);
            
            // Information display
            const display = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 1.5),
                new THREE.MeshBasicMaterial({ color: 0x000080 })
            );
            display.position.set(-2, 2, -1.4);
            display.rotation.y = Math.PI;
            group.add(display);
            
            return group;
        }
        
        function createATM() {
            const group = new THREE.Group();
            
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(1, 2, 0.5),
                new THREE.MeshLambertMaterial({ color: 0x333333 })
            );
            body.position.y = 1;
            body.castShadow = true;
            group.add(body);
            
            const screen = new THREE.Mesh(
                new THREE.PlaneGeometry(0.6, 0.4),
                new THREE.MeshBasicMaterial({ color: 0x0066ff })
            );
            screen.position.set(0, 1.5, 0.26);
            group.add(screen);
            
            return group;
        }
        
        function createPhoneBooth() {
            const group = new THREE.Group();
            
            const booth = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 2.5, 1.5),
                new THREE.MeshLambertMaterial({ 
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.8
                })
            );
            booth.position.y = 1.25;
            booth.castShadow = true;
            group.add(booth);
            
            const door = new THREE.Mesh(
                new THREE.PlaneGeometry(0.8, 2),
                new THREE.MeshLambertMaterial({ 
                    color: 0x660000,
                    transparent: true,
                    opacity: 0.9
                })
            );
            door.position.set(0, 1, 0.76);
            group.add(door);
            
            return group;
        }
        
        function createNaturalElements() {
            // Enhanced tree system
            createAdvancedTreeSystem();
            
            // Parks and green spaces
            createUrbanParks();
        }
        
        function createAdvancedTreeSystem() {
            const treePositions = [];
            
            // Generate realistic tree placement
            for (let i = 0; i < 60; i++) {
                let x, z;
                do {
                    x = (Math.random() - 0.5) * WORLD_SIZE * 1.8;
                    z = (Math.random() - 0.5) * WORLD_SIZE * 1.8;
                } while (
                    (Math.abs(x % 40) < 15 && Math.abs(z % 40) < 15) || // Avoid streets
                    (Math.abs(x) < 15 || Math.abs(z) < 15) // Avoid center
                );
                
                treePositions.push({ x, z, type: Math.random() > 0.5 ? 'oak' : 'pine' });
            }
            
            treePositions.forEach(pos => {
                const tree = createRealisticTree(pos.type);
                tree.position.set(pos.x, 0, pos.z);
                scene.add(tree);
            });
        }
        
        function createRealisticTree(type) {
            const group = new THREE.Group();
            
            if (type === 'oak') {
                // Oak tree
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.4, 0.6, 6),
                    new THREE.MeshLambertMaterial({ color: 0x8b4513 })
                );
                trunk.position.y = 3;
                trunk.castShadow = true;
                group.add(trunk);
                
                // Multiple foliage spheres for realistic shape
                for (let i = 0; i < 3; i++) {
                    const foliage = new THREE.Mesh(
                        new THREE.SphereGeometry(2 + Math.random()),
                        new THREE.MeshLambertMaterial({ color: 0x228b22 })
                    );
                    foliage.position.set(
                        (Math.random() - 0.5) * 2,
                        6 + i * 1.5 + Math.random(),
                        (Math.random() - 0.5) * 2
                    );
                    foliage.castShadow = true;
                    foliage.receiveShadow = true;
                    group.add(foliage);
                }
            } else {
                // Pine tree
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.4, 8),
                    new THREE.MeshLambertMaterial({ color: 0x8b4513 })
                );
                trunk.position.y = 4;
                trunk.castShadow = true;
                group.add(trunk);
                
                // Cone-shaped foliage
                for (let i = 0; i < 4; i++) {
                    const foliage = new THREE.Mesh(
                        new THREE.ConeGeometry(2.5 - i * 0.4, 3),
                        new THREE.MeshLambertMaterial({ color: 0x006400 })
                    );
                    foliage.position.y = 3 + i * 2;
                    foliage.castShadow = true;
                    foliage.receiveShadow = true;
                    group.add(foliage);
                }
            }
            
            return group;
        }
        
        function createUrbanParks() {
            const parkAreas = [
                { x: 120, z: 120, size: 30 },
                { x: -120, z: 120, size: 30 },
                { x: 120, z: -120, size: 30 },
                { x: -120, z: -120, size: 30 }
            ];
            
            parkAreas.forEach(park => {
                createDetailedPark(park.x, park.z, park.size);
            });
        }
        
        function createDetailedPark(x, z, size) {
            // Park ground
            const parkGround = new THREE.Mesh(
                new THREE.PlaneGeometry(size, size),
                new THREE.MeshLambertMaterial({ color: 0x2d7a2d })
            );
            parkGround.rotation.x = -Math.PI / 2;
            parkGround.position.set(x, 0.01, z);
            parkGround.receiveShadow = true;
            scene.add(parkGround);
            
            // Walking paths
            const pathMaterial = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
            const mainPath = new THREE.Mesh(
                new THREE.PlaneGeometry(size * 0.8, 2),
                pathMaterial
            );
            mainPath.rotation.x = -Math.PI / 2;
            mainPath.position.set(x, 0.02, z);
            scene.add(mainPath);
            
            // Park trees
            for (let i = 0; i < 12; i++) {
                const tree = createRealisticTree('oak');
                const treeX = x + (Math.random() - 0.5) * size * 0.8;
                const treeZ = z + (Math.random() - 0.5) * size * 0.8;
                tree.position.set(treeX, 0, treeZ);
                scene.add(tree);
            }
            
            // Park benches and facilities
            for (let i = 0; i < 6; i++) {
                const bench = createParkBench();
                const benchX = x + (Math.random() - 0.5) * size * 0.6;
                const benchZ = z + (Math.random() - 0.5) * size * 0.6;
                bench.position.set(benchX, 0, benchZ);
                bench.rotation.y = Math.random() * Math.PI * 2;
                scene.add(bench);
            }
            
            // Playground equipment
            const playground = createPlayground();
            playground.position.set(x + size * 0.3, 0, z + size * 0.3);
            scene.add(playground);
        }
        
        function createParkBench() {
            const group = new THREE.Group();
            
            // Seat
            const seat = new THREE.Mesh(
                new THREE.BoxGeometry(3, 0.3, 1.2),
                new THREE.MeshLambertMaterial({ color: 0x8b4513 })
            );
            seat.position.y = 1;
            seat.castShadow = true;
            group.add(seat);
            
            // Backrest
            const back = new THREE.Mesh(
                new THREE.BoxGeometry(3, 1.8, 0.3),
                new THREE.MeshLambertMaterial({ color: 0x8b4513 })
            );
            back.position.set(0, 1.6, -0.45);
            back.castShadow = true;
            group.add(back);
            
            // Metal frame
            for (let i = 0; i < 2; i++) {
                const support = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 1, 1.2),
                    new THREE.MeshLambertMaterial({ color: 0x444444 })
                );
                support.position.set(i * 2.8 - 1.4, 0.5, 0);
                support.castShadow = true;
                group.add(support);
            }
            
            return group;
        }
        
        function createPlayground() {
            const group = new THREE.Group();
            
            // Swing set
            const swingFrame = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 3, 4),
                new THREE.MeshLambertMaterial({ color: 0x666666 })
            );
            swingFrame.position.y = 1.5;
            swingFrame.castShadow = true;
            group.add(swingFrame);
            
            // Swings
            for (let i = 0; i < 2; i++) {
                const swing = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 0.1, 0.5),
                    new THREE.MeshLambertMaterial({ color: 0xff6600 })
                );
                swing.position.set(0, 0.8, i * 2 - 1);
                swing.castShadow = true;
                group.add(swing);
            }
            
            // Slide
            const slide = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.1, 6),
                new THREE.MeshLambertMaterial({ color: 0x0066ff })
            );
            slide.position.set(3, 1, 0);
            slide.rotation.x = -Math.PI / 6;
            slide.castShadow = true;
            group.add(slide);
            
            return group;
        }
        
        async function loadPlayerModel() {
            try {
                console.log("Loading realistic player model...");
                const gltf = await loader.loadAsync('client/public/models/player.glb');
                
                gameState.playerModel = gltf.scene;
                gameState.playerModel.scale.setScalar(2.5); // Scale up for visibility
                gameState.playerModel.position.set(0, 0, 10);
                gameState.playerModel.castShadow = true;
                gameState.playerModel.receiveShadow = true;
                
                // Setup animations if available
                if (gltf.animations && gltf.animations.length > 0) {
                    gameState.mixer = new THREE.AnimationMixer(gameState.playerModel);
                    gltf.animations.forEach((clip) => {
                        gameState.animations[clip.name] = gameState.mixer.clipAction(clip);
                    });
                }
                
                // Make all meshes cast shadows
                gameState.playerModel.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                scene.add(gameState.playerModel);
                player = gameState.playerModel;
                
                console.log("Realistic player model loaded successfully!");
                
                // Load NPC models
                await loadNPCModels();
                
            } catch (error) {
                console.warn("Could not load GLB model, using fallback...", error);
                createFallbackPlayer();
            }
        }
        
        async function loadNPCModels() {
            try {
                console.log("Loading NPC models...");
                
                // Load female NPC model
                const femaleGltf = await loader.loadAsync('client/public/models/npc_female.glb');
                
                // Create multiple NPCs with the loaded model
                for (let i = 0; i < 8; i++) {
                    const npcModel = femaleGltf.scene.clone();
                    npcModel.scale.setScalar(2.2);
                    
                    const x = (Math.random() - 0.5) * 80;
                    const z = (Math.random() - 0.5) * 80;
                    npcModel.position.set(x, 0, z);
                    
                    npcModel.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    // Add AI behavior data
                    npcModel.userData = {
                        type: ['walker', 'shopper', 'idle'][Math.floor(Math.random() * 3)],
                        name: `NPC_${i + 1}`,
                        animationTime: Math.random() * Math.PI * 2,
                        direction: Math.random() * Math.PI * 2,
                        speed: 0.02 + Math.random() * 0.03,
                        originalPosition: { x: x, z: z },
                        walkRadius: 15 + Math.random() * 20,
                        state: 'idle',
                        stateTime: 0
                    };
                    
                    npcs.push(npcModel);
                    scene.add(npcModel);
                }
                
                console.log(`${npcs.length} realistic NPCs loaded!`);
                
            } catch (error) {
                console.warn("Could not load NPC models, using fallback...", error);
                createFallbackNPCs();
            }
        }
        
        function createFallbackPlayer() {
            player = new THREE.Group();
            
            // Enhanced fallback player
            const bodyGeometry = new THREE.BoxGeometry(1.2, 2.4, 0.6);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x0066ff });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.2;
            body.castShadow = true;
            player.add(body);
            
            const headGeometry = new THREE.SphereGeometry(0.4);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.8;
            head.castShadow = true;
            player.add(head);
            
            player.position.set(0, 0, 10);
            scene.add(player);
            gameState.playerModel = player;
        }
        
        function createFallbackNPCs() {
            for (let i = 0; i < 8; i++) {
                const npc = new THREE.Group();
                
                const body = new THREE.Mesh(
                    new THREE.BoxGeometry(0.9, 2.1, 0.5),
                    new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff })
                );
                body.position.y = 1.05;
                body.castShadow = true;
                npc.add(body);
                
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35),
                    new THREE.MeshLambertMaterial({ color: 0xffdbac })
                );
                head.position.y = 2.4;
                head.castShadow = true;
                npc.add(head);
                
                const x = (Math.random() - 0.5) * 80;
                const z = (Math.random() - 0.5) * 80;
                npc.position.set(x, 0, z);
                
                npc.userData = {
                    type: ['walker', 'shopper', 'idle'][Math.floor(Math.random() * 3)],
                    name: `NPC_${i + 1}`,
                    animationTime: Math.random() * Math.PI * 2,
                    direction: Math.random() * Math.PI * 2,
                    speed: 0.02 + Math.random() * 0.03,
                    originalPosition: { x: x, z: z },
                    walkRadius: 15 + Math.random() * 20,
                    state: 'idle',
                    stateTime: 0
                };
                
                npcs.push(npc);
                scene.add(npc);
            }
        }
        
        async function createAdvancedVehicles() {
            try {
                console.log("Loading vehicle models...");
                const carGltf = await loader.loadAsync('client/public/models/sports_car.glb');
                
                const vehiclePositions = [
                    { x: 20, z: 5, type: 'sports' },
                    { x: -20, z: 5, type: 'sports' },
                    { x: 5, z: 20, type: 'sports' },
                    { x: 5, z: -20, type: 'sports' },
                    { x: 40, z: 20, type: 'sports' },
                    { x: -40, z: 20, type: 'sports' }
                ];
                
                vehiclePositions.forEach((config, index) => {
                    const vehicle = carGltf.scene.clone();
                    vehicle.scale.setScalar(3);
                    vehicle.position.set(config.x, 0, config.z);
                    vehicle.rotation.y = Math.random() * Math.PI * 2;
                    
                    vehicle.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    vehicle.userData = {
                        type: config.type,
                        speed: 0,
                        maxSpeed: VEHICLE_SPEED,
                        occupied: false,
                        health: 100,
                        id: index
                    };
                    
                    vehicles.push(vehicle);
                    scene.add(vehicle);
                });
                
                console.log(`${vehicles.length} realistic vehicles loaded!`);
                
            } catch (error) {
                console.warn("Could not load vehicle models, using fallback...", error);
                createFallbackVehicles();
            }
        }
        
        function createFallbackVehicles() {
            const vehicleConfigs = [
                { x: 20, z: 5, color: 0xff0000 },
                { x: -20, z: 5, color: 0x00ff00 },
                { x: 5, z: 20, color: 0x0000ff },
                { x: 5, z: -20, color: 0xffff00 },
                { x: 40, z: 20, color: 0xff00ff },
                { x: -40, z: 20, color: 0x00ffff }
            ];
            
            vehicleConfigs.forEach((config, index) => {
                const vehicle = new THREE.Group();
                
                const body = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 1.5, 4.5),
                    new THREE.MeshLambertMaterial({ color: config.color })
                );
                body.position.y = 1.25;
                body.castShadow = true;
                vehicle.add(body);
                
                // Wheels
                for (let i = 0; i < 4; i++) {
                    const wheel = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.4, 0.3),
                        new THREE.MeshLambertMaterial({ color: 0x222222 })
                    );
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(
                        i % 2 === 0 ? -1.2 : 1.2,
                        0.4,
                        i < 2 ? 1.5 : -1.5
                    );
                    wheel.castShadow = true;
                    vehicle.add(wheel);
                }
                
                vehicle.position.set(config.x, 0, config.z);
                vehicle.userData = {
                    type: 'sedan',
                    speed: 0,
                    maxSpeed: VEHICLE_SPEED,
                    occupied: false,
                    health: 100,
                    id: index
                };
                
                vehicles.push(vehicle);
                scene.add(vehicle);
            });
        }
        
        function createIntelligentNPCs() {
            // NPCs are created in loadNPCModels or createFallbackNPCs
            console.log("AI system initialized for NPCs");
        }
        
        function setupMobileControls() {
            const joystickElement = document.getElementById('joystick');
            const joystickKnob = document.getElementById('joystick-knob');
            const actionButtons = {
                shoot: document.getElementById('shootBtn'),
                interact: document.getElementById('interactBtn'),
                phone: document.getElementById('phoneBtn'),
                jump: document.getElementById('jumpBtn')
            };
            
            // Joystick controls
            let joystickRect = joystickElement.getBoundingClientRect();
            
            function updateJoystickRect() {
                joystickRect = joystickElement.getBoundingClientRect();
                joystick.center.x = joystickRect.left + joystickRect.width / 2;
                joystick.center.y = joystickRect.top + joystickRect.height / 2;
            }
            
            updateJoystickRect();
            window.addEventListener('resize', updateJoystickRect);
            window.addEventListener('orientationchange', () => {
                setTimeout(updateJoystickRect, 100);
            });
            
            // Touch event handlers
            function handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickElement.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const dx = touch.clientX - centerX;
                const dy = touch.clientY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance <= rect.width / 2) {
                    joystick.active = true;
                    joystick.center.x = centerX;
                    joystick.center.y = centerY;
                    updateJoystick(touch.clientX, touch.clientY);
                }
            }
            
            function handleTouchMove(e) {
                e.preventDefault();
                if (joystick.active && e.touches.length > 0) {
                    updateJoystick(e.touches[0].clientX, e.touches[0].clientY);
                }
            }
            
            function handleTouchEnd(e) {
                e.preventDefault();
                if (joystick.active) {
                    joystick.active = false;
                    touchControls.moveX = 0;
                    touchControls.moveY = 0;
                    joystickKnob.style.transform = 'translate(0px, 0px)';
                }
            }
            
            function updateJoystick(touchX, touchY) {
                const dx = touchX - joystick.center.x;
                const dy = touchY - joystick.center.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const maxDistance = 35; // Maximum joystick radius
                
                if (distance > maxDistance) {
                    const angle = Math.atan2(dy, dx);
                    joystick.current.x = Math.cos(angle) * maxDistance;
                    joystick.current.y = Math.sin(angle) * maxDistance;
                } else {
                    joystick.current.x = dx;
                    joystick.current.y = dy;
                }
                
                // Update visual position
                joystickKnob.style.transform = `translate(${joystick.current.x}px, ${joystick.current.y}px)`;
                
                // Update movement values
                touchControls.moveX = joystick.current.x / maxDistance;
                touchControls.moveY = joystick.current.y / maxDistance;
            }
            
            // Add event listeners
            joystickElement.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            // Action button handlers
            actionButtons.shoot.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startShooting();
            });
            
            actionButtons.shoot.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopShooting();
            });
            
            actionButtons.interact.addEventListener('touchstart', (e) => {
                e.preventDefault();
                interactWithNPC();
            });
            
            actionButtons.phone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                togglePhone();
            });
            
            actionButtons.jump.addEventListener('touchstart', (e) => {
                e.preventDefault();
                playerJump();
            });
            
            // Prevent default touch behaviors
            document.addEventListener('touchstart', (e) => {
                if (e.target.closest('.mobile-controls')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
        }
        
        function startShooting() {
            if (gameState.ammo > 0) {
                gameState.isShooting = true;
                shoot();
                showNotification("Shooting!");
            } else {
                showNotification("No ammo!");
            }
        }
        
        function stopShooting() {
            gameState.isShooting = false;
        }
        
        function shoot() {
            if (gameState.ammo <= 0) return;
            
            gameState.ammo--;
            
            // Create bullet
            const bullet = new THREE.Mesh(
                new THREE.SphereGeometry(0.1),
                new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.5
                })
            );
            
            // Position bullet at player position
            bullet.position.copy(player.position);
            bullet.position.y += 2;
            
            // Calculate bullet direction based on camera
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            
            bullet.userData = {
                velocity: direction.multiplyScalar(BULLET_SPEED),
                life: 3.0 // 3 seconds lifetime
            };
            
            bullets.push(bullet);
            scene.add(bullet);
            
            // Increase wanted level if shooting in city
            if (gameState.wantedLevel < 5) {
                gameState.wantedLevel += 0.2;
                updateWantedLevel();
            }
            
            // Muzzle flash effect
            createMuzzleFlash();
            
            console.log(`Shot fired! Ammo: ${gameState.ammo}`);
        }
        
        function createMuzzleFlash() {
            const flash = new THREE.Mesh(
                new THREE.SphereGeometry(0.3),
                new THREE.MeshBasicMaterial({ 
                    color: 0xffaa00,
                    transparent: true,
                    opacity: 0.8
                })
            );
            
            flash.position.copy(player.position);
            flash.position.y += 2;
            scene.add(flash);
            
            setTimeout(() => {
                scene.remove(flash);
            }, 100);
        }
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Move bullet
                bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(0.016));
                
                // Decrease lifetime
                bullet.userData.life -= 0.016;
                
                // Check for collisions with NPCs
                for (let npc of npcs) {
                    const distance = bullet.position.distanceTo(npc.position);
                    if (distance < 2) {
                        // Hit NPC
                        createHitEffect(npc.position);
                        scene.remove(bullet);
                        bullets.splice(i, 1);
                        
                        // NPC reaction (could remove or make them run)
                        if (Math.random() > 0.5) {
                            scene.remove(npc);
                            npcs.splice(npcs.indexOf(npc), 1);
                        }
                        
                        gameState.wantedLevel += 1;
                        updateWantedLevel();
                        break;
                    }
                }
                
                // Remove bullet if lifetime expired or out of bounds
                if (bullet.userData.life <= 0 || Math.abs(bullet.position.x) > 200 || Math.abs(bullet.position.z) > 200) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                }
            }
        }
        
        function createHitEffect(position) {
            // Create hit particle effect
            for (let i = 0; i < 5; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05),
                    new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );
                
                particle.position.copy(position);
                particle.position.y += 1;
                
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    Math.random() * 2,
                    (Math.random() - 0.5) * 2
                );
                
                particle.userData = { velocity: velocity, life: 1.0 };
                scene.add(particle);
                
                // Remove particle after effect
                setTimeout(() => {
                    scene.remove(particle);
                }, 1000);
            }
        }
        
        function interactWithNPC() {
            let nearestNPC = null;
            let nearestDistance = Infinity;
            
            npcs.forEach(npc => {
                const distance = player.position.distanceTo(npc.position);
                if (distance < 5 && distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestNPC = npc;
                }
            });
            
            if (nearestNPC) {
                const dialogues = [
                    "Hello there!",
                    "Nice weather today.",
                    "Have you seen the news?",
                    "This city is getting crazy!",
                    "Stay safe out there."
                ];
                
                const dialogue = dialogues[Math.floor(Math.random() * dialogues.length)];
                showNotification(`${nearestNPC.userData.name}: "${dialogue}"`);
                
                // NPC looks at player
                const direction = new THREE.Vector3();
                direction.subVectors(player.position, nearestNPC.position);
                nearestNPC.rotation.y = Math.atan2(direction.x, direction.z);
            } else {
                showNotification("No one nearby to talk to.");
            }
        }
        
        function togglePhone() {
            const phoneModal = document.getElementById('phoneModal');
            gameState.phoneOpen = !gameState.phoneOpen;
            phoneModal.style.display = gameState.phoneOpen ? 'flex' : 'none';
            
            if (gameState.phoneOpen) {
                showNotification("Phone opened");
            }
        }
        
        function callPolice() {
            if (gameState.wantedLevel > 0) {
                gameState.wantedLevel = Math.max(0, gameState.wantedLevel - 2);
                updateWantedLevel();
                showNotification("Police called! Wanted level reduced.");
                gameState.money -= 100;
            } else {
                showNotification("Police: Everything looks normal.");
            }
            closePhone();
        }
        
        function callAmbulance() {
            if (gameState.health < 100) {
                gameState.health = Math.min(100, gameState.health + 50);
                showNotification("Ambulance called! Health restored.");
                gameState.money -= 200;
            } else {
                showNotification("Ambulance: You look fine!");
            }
            closePhone();
        }
        
        function callTaxi() {
            const randomX = (Math.random() - 0.5) * 100;
            const randomZ = (Math.random() - 0.5) * 100;
            player.position.set(randomX, 0, randomZ);
            showNotification("Taxi ride complete!");
            gameState.money -= 50;
            closePhone();
        }
        
        function closePhone() {
            gameState.phoneOpen = false;
            document.getElementById('phoneModal').style.display = 'none';
        }
        
        function playerJump() {
            if (!gameState.isJumping) {
                gameState.isJumping = true;
                const originalY = player.position.y;
                
                // Jump animation
                const jumpHeight = 3;
                const jumpDuration = 600; // ms
                const startTime = Date.now();
                
                function animateJump() {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / jumpDuration;
                    
                    if (progress < 1) {
                        const height = originalY + jumpHeight * Math.sin(progress * Math.PI);
                        player.position.y = height;
                        requestAnimationFrame(animateJump);
                    } else {
                        player.position.y = originalY;
                        gameState.isJumping = false;
                    }
                }
                
                animateJump();
                showNotification("Jump!");
            }
        }
        
        function updateMovement() {
            if (!player) return;
            
            const velocity = new THREE.Vector3();
            let isMoving = false;
            
            // Mobile touch controls
            if (Math.abs(touchControls.moveX) > 0.1 || Math.abs(touchControls.moveY) > 0.1) {
                velocity.x = touchControls.moveX;
                velocity.z = touchControls.moveY;
                isMoving = true;
            }
            
            if (isMoving) {
                velocity.normalize();
                const speed = WALK_SPEED * (gameState.isRunning ? 2 : 1);
                velocity.multiplyScalar(speed);
                
                // Apply movement
                const newPosition = player.position.clone().add(velocity);
                if (!checkCollisions(newPosition)) {
                    player.position.add(velocity);
                }
                
                // Update player rotation
                if (velocity.length() > 0) {
                    const angle = Math.atan2(velocity.x, velocity.z);
                    player.rotation.y = angle;
                }
                
                // Animate player if using GLB model
                if (gameState.mixer && gameState.animations.walk) {
                    gameState.animations.walk.play();
                }
            } else {
                // Stop walking animation
                if (gameState.mixer && gameState.animations.walk) {
                    gameState.animations.walk.stop();
                }
            }
            
            // Update animation mixer
            if (gameState.mixer) {
                gameState.mixer.update(clock.getDelta());
            }
        }
        
        function checkCollisions(position) {
            // Check building collisions
            for (let building of buildings) {
                const buildingBox = new THREE.Box3().setFromObject(building);
                const playerBox = new THREE.Box3().setFromCenterAndSize(
                    position,
                    new THREE.Vector3(2, 4, 2)
                );
                
                if (buildingBox.intersectsBox(playerBox)) {
                    return true;
                }
            }
            
            // Check vehicle collisions
            for (let vehicle of vehicles) {
                if (vehicle !== gameState.currentVehicle) {
                    const vehicleBox = new THREE.Box3().setFromObject(vehicle);
                    const playerBox = new THREE.Box3().setFromCenterAndSize(
                        position,
                        new THREE.Vector3(2, 4, 2)
                    );
                    
                    if (vehicleBox.intersectsBox(playerBox)) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        function updateNPCs() {
            npcs.forEach(npc => {
                updateNPCAI(npc);
            });
        }
        
        function updateNPCAI(npc) {
            const userData = npc.userData;
            userData.stateTime += 0.016;
            
            switch (userData.type) {
                case 'walker':
                    if (userData.stateTime > 3) {
                        userData.stateTime = 0;
                        userData.direction = Math.random() * Math.PI * 2;
                        userData.state = Math.random() > 0.3 ? 'walking' : 'idle';
                    }
                    
                    if (userData.state === 'walking') {
                        const velocity = new THREE.Vector3(
                            Math.sin(userData.direction) * userData.speed,
                            0,
                            Math.cos(userData.direction) * userData.speed
                        );
                        
                        const newPosition = npc.position.clone().add(velocity);
                        const distanceFromOrigin = newPosition.distanceTo(
                            new THREE.Vector3(userData.originalPosition.x, 0, userData.originalPosition.z)
                        );
                        
                        if (distanceFromOrigin < userData.walkRadius) {
                            npc.position.add(velocity);
                            npc.rotation.y = userData.direction;
                        }
                    }
                    break;
                    
                case 'shopper':
                    // Similar to walker but with pauses
                    if (userData.stateTime > 5) {
                        userData.stateTime = 0;
                        userData.direction = Math.random() * Math.PI * 2;
                        userData.state = Math.random() > 0.5 ? 'walking' : 'shopping';
                    }
                    break;
                    
                case 'idle':
                    // Mostly stationary
                    if (userData.stateTime > 8) {
                        userData.stateTime = 0;
                        userData.direction = Math.random() * Math.PI * 2;
                        npc.rotation.y = userData.direction;
                    }
                    break;
            }
        }
        
        function updateCamera() {
            if (!player) return;
            
            // Third-person camera following player
            const idealOffset = new THREE.Vector3(0, 8, 15);
            idealOffset.applyEuler(player.rotation);
            
            const idealPosition = player.position.clone().add(idealOffset);
            
            // Smooth camera movement
            camera.position.lerp(idealPosition, 0.05);
            camera.lookAt(player.position);
        }
        
        function updateWantedLevel() {
            const stars = document.querySelectorAll('.star');
            const level = Math.floor(gameState.wantedLevel);
            
            stars.forEach((star, index) => {
                if (index < level) {
                    star.classList.add('active');
                } else {
                    star.classList.remove('active');
                }
            });
        }
        
        function setupMinimap() {
            const canvas = document.getElementById('minimapCanvas');
            minimapCtx = canvas.getContext('2d');
            
            // Set canvas size based on screen orientation
            const size = window.innerWidth < window.innerHeight ? 150 : 120;
            canvas.width = size;
            canvas.height = size;
        }
        
        function updateMinimap() {
            if (!minimapCtx || !player) return;
            
            const canvas = minimapCtx.canvas;
            const size = canvas.width;
            
            // Clear minimap
            minimapCtx.fillStyle = '#1a4a1a';
            minimapCtx.fillRect(0, 0, size, size);
            
            const scale = size / (WORLD_SIZE * 1.5);
            const centerX = size / 2;
            const centerY = size / 2;
            
            // Draw streets
            minimapCtx.fillStyle = '#666';
            for (let i = -5; i <= 5; i++) {
                // Horizontal streets
                const streetY = centerY + (i * 40) * scale;
                if (streetY >= 0 && streetY <= size) {
                    minimapCtx.fillRect(0, streetY - 1, size, 2);
                }
                
                // Vertical streets
                const streetX = centerX + (i * 40) * scale;
                if (streetX >= 0 && streetX <= size) {
                    minimapCtx.fillRect(streetX - 1, 0, 2, size);
                }
            }
            
            // Draw buildings
            minimapCtx.fillStyle = '#888';
            buildings.forEach(building => {
                const x = centerX + building.position.x * scale;
                const y = centerY + building.position.z * scale;
                if (x >= 0 && x <= size && y >= 0 && y <= size) {
                    minimapCtx.fillRect(x - 2, y - 2, 4, 4);
                }
            });
            
            // Draw vehicles
            minimapCtx.fillStyle = '#ff0';
            vehicles.forEach(vehicle => {
                const x = centerX + vehicle.position.x * scale;
                const y = centerY + vehicle.position.z * scale;
                if (x >= 0 && x <= size && y >= 0 && y <= size) {
                    minimapCtx.fillRect(x - 1, y - 1, 2, 2);
                }
            });
            
            // Draw NPCs
            minimapCtx.fillStyle = '#0f0';
            npcs.forEach(npc => {
                const x = centerX + npc.position.x * scale;
                const y = centerY + npc.position.z * scale;
                if (x >= 0 && x <= size && y >= 0 && y <= size) {
                    minimapCtx.fillRect(x - 0.5, y - 0.5, 1, 1);
                }
            });
            
            // Draw player
            minimapCtx.fillStyle = '#00f';
            const playerX = centerX + player.position.x * scale;
            const playerY = centerY + player.position.z * scale;
            minimapCtx.fillRect(playerX - 2, playerY - 2, 4, 4);
            
            // Draw player direction
            minimapCtx.strokeStyle = '#00f';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(playerX, playerY);
            const dirX = playerX + Math.sin(player.rotation.y) * 8;
            const dirY = playerY + Math.cos(player.rotation.y) * 8;
            minimapCtx.lineTo(dirX, dirY);
            minimapCtx.stroke();
        }
        
        function updateUI() {
            // Update health bar
            const healthBar = document.getElementById('healthBar');
            healthBar.style.width = `${gameState.health}%`;
            
            // Update speed
            const speedElement = document.getElementById('speed');
            const currentSpeed = Math.sqrt(
                touchControls.moveX * touchControls.moveX + 
                touchControls.moveY * touchControls.moveY
            ) * 100;
            speedElement.textContent = Math.round(currentSpeed);
            
            // Update ammo
            document.getElementById('ammo').textContent = `${gameState.ammo}/${gameState.maxAmmo}`;
            document.getElementById('weaponAmmo').textContent = `${gameState.ammo}/${gameState.maxAmmo}`;
            
            // Update money
            document.getElementById('money').textContent = gameState.money;
            
            // Update weapon display
            document.getElementById('currentWeapon').textContent = gameState.currentWeapon.toUpperCase();
        }
        
        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Update minimap size
            setupMinimap();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update game systems
            updateMovement();
            updateBullets();
            updateNPCs();
            updateCamera();
            updateMinimap();
            updateUI();
            
            // Reduce wanted level over time
            if (gameState.wantedLevel > 0) {
                gameState.wantedLevel = Math.max(0, gameState.wantedLevel - 0.001);
                updateWantedLevel();
            }
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Handle orientation changes
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                onWindowResize();
                if (screen.orientation) {
                    console.log('Orientation:', screen.orientation.angle);
                }
            }, 100);
        });
        
        window.addEventListener('resize', onWindowResize);
        
        // Prevent zoom on double tap
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        // Initialize the game
        window.addEventListener('load', () => {
            init();
        });
        
        // Expose debug functions
        window.gameDebug = {
            addMoney: (amount) => {
                gameState.money += amount;
                showNotification(`Added $${amount}`);
            },
            addAmmo: (amount) => {
                gameState.ammo = Math.min(gameState.maxAmmo, gameState.ammo + amount);
                showNotification(`Added ${amount} ammo`);
            },
            clearWanted: () => {
                gameState.wantedLevel = 0;
                updateWantedLevel();
                showNotification("Wanted level cleared");
            },
            teleport: (x, z) => {
                player.position.set(x, 0, z);
                showNotification(`Teleported to ${x}, ${z}`);
            }
        };
        
        console.log("Advanced Mobile 3D GTA Game - Ready to play!");
        console.log("Debug commands: gameDebug.addMoney(1000), gameDebug.addAmmo(30), gameDebug.clearWanted()");
    </script>
</body>
</html>
